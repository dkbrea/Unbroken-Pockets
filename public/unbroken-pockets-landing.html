<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Financial Freedom | Personal Finance Management</title>
  <!-- Add Google Fonts - Playfair Display for serif elegance -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <!-- Import Three.js for the sphere rendering -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background-color: #0a0b0e;
      color: #fff;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      position: relative;
      height: 100vh;
      margin: 0;
      padding: 0;
    }
    
    /* Overlay container for the masked image effect */
    .entrance-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 100; /* Higher z-index to ensure it's on top initially */
      pointer-events: none;
      overflow: hidden;
    }
    
    /* The main image layer - this will be divided into panels */
    .entrance-image {
      display: none; /* Hide the full image as we'll use panels instead */
    }
    
    /* The mask container */
    .mask-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 5;
      display: flex;
      flex-direction: row;
      pointer-events: none;
      transform-style: preserve-3d;
      perspective: 1000px;
      will-change: transform;
      transition: transform 0.1s ease-out;
    }
    
    /* The panels/masks - each containing part of the image */
    .mask-panel {
      height: 100%;
      transition: transform 0.8s cubic-bezier(0.19, 1, 0.22, 1), opacity 0.8s ease;
      position: relative;
      overflow: visible;
      background-color: #000;
      z-index: 10;
    }
    
    /* Panel background elements */
    .panel-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url('https://images.unsplash.com/photo-1519681393784-d120267933ba?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2070&q=80');
      background-size: cover;
      background-position: center;
      z-index: 0;
      transition: transform 0.6s cubic-bezier(0.19, 1, 0.22, 1); /* Faster transition */
    }
    
    /* Specific positioning for each panel's background */
    .left-background {
      background-position: left center;
      opacity: 1;
    }
    
    .center-background {
      background-position: center;
      opacity: 0.7;
    }
    
    .right-background {
      background-position: right center;
      opacity: 1;
    }
    
    /* Black rectangle extensions for left and right panels */
    .mask-left::after, .mask-right::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 0;
      width: 100%;
      height: 300vh;
      background-color: #000;
      z-index: 90;
    }
    
    .mask-left {
      width: 33.33%;
      border-right: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .mask-center {
      width: 33.34%;
      position: relative;
      overflow: visible;
      border-left: 1px solid rgba(255, 255, 255, 0.2);
      border-right: 1px solid rgba(255, 255, 255, 0.2);
      opacity: 1;
      transition: opacity 0.8s ease, transform 0.6s cubic-bezier(0.19, 1, 0.22, 1); /* Faster transition */
      background-color: transparent;
      z-index: 11;
      transform-origin: center center;
    }
    
    .mask-right {
      width: 33.33%;
      border-left: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    /* The peephole that will grow in the center */
    .peephole {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0; /* Start with zero size again to ensure proper animation */
      height: 0; /* Start with zero size again to ensure proper animation */
      border-radius: 50%; /* Start as circle, will become pill-shaped */
      transform: translate(-50%, -50%);
      background-color: rgba(10, 11, 14, 0.95); /* Dark background matching the body */
      z-index: 20; /* Lower z-index to allow proper stacking with mask-center */
      transition: all 1.8s cubic-bezier(0.19, 1, 0.22, 1); /* Keep this slower */
      pointer-events: none;
      overflow: hidden; /* Hide content that overflows initially */
      box-shadow: 0 0 50px rgba(255, 255, 255, 0.1); /* Add a subtle glow for visibility */
      will-change: transform, width, height;
    }
    
    /* Content inside the peephole */
    .peephole-content {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      opacity: 0;
      transform: scale(0.9); /* Initially smaller */
      transition: opacity 1s ease, transform 1s cubic-bezier(0.19, 1, 0.22, 1);
    }
    
    /* Position content overlay to be centered in the peephole */
    .content-overlay {
      display: none; /* Remove since we don't need it anymore */
    }
    
    .fixed-content {
      display: none; /* Remove since we don't need it anymore */
    }
    
    /* Decorative spheres on the entrance image */
    .landscape-sphere {
      position: absolute;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.1));
      border-radius: 50%;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
      z-index: 105;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transform-style: preserve-3d;
      will-change: transform;
    }
    
    .landscape-sphere::before {
      content: '';
      position: absolute;
      top: 20%;
      left: 20%;
      width: 30%;
      height: 30%;
      background: radial-gradient(circle at center, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));
      border-radius: 50%;
      filter: blur(2px);
    }
    
    .sphere-top {
      width: 80px;
      height: 80px;
      top: 60px;
      left: 50%;
      transform: translateX(-50%) translateZ(20px);
    }
    
    .sphere-left {
      width: 160px;
      height: 160px;
      left: 100px;
      top: 200px;
      transform: translateZ(40px);
    }
    
    .sphere-right {
      width: 120px;
      height: 120px;
      right: 120px;
      top: 180px;
      transform: translateZ(30px);
    }
    
    /* Decorative spheres now inside the peephole */
    .sphere-decoration {
      position: absolute;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.1));
      border-radius: 50%;
      pointer-events: none;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
      z-index: 40;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transform-style: preserve-3d;
      will-change: transform;
      transition: transform 0.1s ease-out;
    }
    
    .sphere-decoration::before {
      content: '';
      position: absolute;
      top: 20%;
      left: 20%;
      width: 30%;
      height: 30%;
      background: radial-gradient(circle at center, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));
      border-radius: 50%;
      filter: blur(2px);
    }
    
    .sphere-1 {
      width: 100px;
      height: 100px;
      top: 15%;
      left: 15%;
    }
    
    .sphere-2 {
      width: 60px;
      height: 60px;
      top: 30%;
      right: 20%;
    }
    
    .sphere-3 {
      width: 80px;
      height: 80px;
      bottom: 20%;
      right: 15%;
    }
    
    .sphere-4 {
      width: 40px;
      height: 40px;
      top: 60%;
      left: 25%;
    }
    
    .container {
      position: relative;
      height: 700vh;
      width: 100%;
    }
    
    .heading {
      text-align: center;
      position: absolute;
      top: 12%;
      left: 0;
      width: 100%;
      margin-bottom: 0;
      transition: transform 0.8s cubic-bezier(0.19, 1, 0.22, 1), opacity 0.8s ease;
      will-change: transform, opacity;
      z-index: 30;
      font-family: 'Playfair Display', serif;
      padding: 0 20px;
      transform: scale(0.8); /* Initially smaller to fit peephole */
    }
    
    .heading h1 {
      font-size: 7rem;
      font-weight: 700;
      line-height: 1.1;
      letter-spacing: -0.02em;
      margin: 0;
      color: #ffffff;
      text-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
    }
    
    .heading h2 {
      font-size: 4.5rem;
      font-weight: 400;
      line-height: 1.2;
      margin-top: 1rem;
      color: rgba(255, 255, 255, 0.9);
    }
    
    #sphereContainer {
      width: 300px; /* Smaller to fit inside the peephole */
      height: 300px;
      margin: 0 auto;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      transform-style: preserve-3d;
      perspective: 1000px;
      transition: transform 0.8s cubic-bezier(0.19, 1, 0.22, 1), opacity 0.8s ease;
      will-change: transform, opacity;
      z-index: 20;
    }
    
    .grid {
      position: relative;
      transform-origin: center bottom;
      transform: perspective(1000px) rotateX(35deg) scale(0.7); /* Initially smaller */
      z-index: 0;
      display: grid;
      grid-template-columns: repeat(5, 120px); /* Smaller cells */
      grid-template-rows: repeat(5, 120px);
      opacity: 1;
      transition: transform 1.5s cubic-bezier(0.19, 1, 0.22, 1), opacity 0.4s ease;
      padding: 10px;
      transform-style: preserve-3d;
      gap: 10px;
      background-color: transparent;
      width: auto;
      height: auto;
      max-width: 90vw;
      pointer-events: auto;
      margin-top: -150px; /* Adjust for peephole */
    }
    
    /* Ensure text elements in the grid have correct relative sizing */
    .grid .card-title {
      font-size: 14px;
    }
    
    .grid .card-subtitle {
      font-size: 11px;
    }
    
    .grid .tag {
      font-size: 10px;
    }
    
    .grid .btn {
      font-size: 12px;
    }
    
    .grid.flat {
      transform: perspective(1000px) rotateX(25deg) scale(1.0);
    }
    
    .grid.upright {
      transform: perspective(1000px) rotateX(0deg) scale(1.0);
    }
    
    .grid-cell {
      border: 1px solid rgba(255, 255, 255, 0.1);
      position: relative;
      box-sizing: border-box;
      transition: background-color 0.5s ease, box-shadow 0.5s ease, transform 0.3s ease;
      background-color: rgba(15, 23, 42, 0.3);
      border-radius: 10px;
      backdrop-filter: blur(3px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      width: 120px; /* Smaller cells */
      height: 120px;
      transform-style: preserve-3d;
      transform: translateZ(0);
    }
    
    .grid-cell:hover {
      background-color: rgba(220, 180, 120, 0.1);
      border-color: rgba(220, 180, 120, 0.3);
      box-shadow: 0 0 20px rgba(201, 166, 103, 0.2);
    }
    
    /* Add blue dot in top right corner like in reference */
    .grid-cell::after {
      content: '';
      position: absolute;
      top: 8px;
      right: 8px;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background-color: #38bdf8;
      opacity: 0.8;
    }
    
    .card {
      position: absolute;
      width: 110px; /* Smaller cards */
      height: 110px;
      background-color: rgba(10, 15, 25, 0.85);
      border: 1px solid rgba(71, 85, 105, 0.4);
      border-radius: 8px;
      padding: 10px;
      opacity: 1;
      transition: all 0.6s cubic-bezier(0.19, 1, 0.22, 1);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
      backdrop-filter: blur(5px);
      z-index: 20;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      overflow: visible;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      position: relative;
    }
    
    /* Ensure peephole expands to fullscreen properly */
    .peephole.expanded {
      width: 100% !important;
      height: 100% !important;
      border-radius: 0 !important;
    }
    
    /* Adjust card animations */
    .card.horizontal-line {
      position: absolute;
      transition: all 0.8s cubic-bezier(0.19, 1, 0.22, 1);
    }
    
    /* Add subtle gradient border glow */
    .card::before {
      content: '';
      position: absolute;
      inset: -1px;
      border-radius: 9px;
      background: linear-gradient(135deg, rgba(236, 211, 148, 0.05), rgba(201, 166, 103, 0.3), rgba(163, 133, 72, 0.05));
      z-index: -1;
      opacity: 1;
      transition: opacity 0.3s ease;
    }
    
    .card:hover::before {
      opacity: 1;
      background: linear-gradient(135deg, rgba(236, 211, 148, 0.1), rgba(201, 166, 103, 0.5), rgba(163, 133, 72, 0.1));
    }
    
    .card.in-grid:hover {
      box-shadow: 0 8px 30px rgba(220, 180, 120, 0.3);
      transform: translate(-50%, -50%) scale(1.05);
      border-color: rgba(220, 180, 120, 0.1);
    }
    
    .card.in-grid:hover .card-title {
      color: #ecd394;
      transform: translateY(-2px);
    }
    
    /* Profile card (bottom-left) */
    .profile-card {
      display: flex;
      flex-direction: column;
    }
    
    .avatar-container {
      width: 100%;
      height: 80px;
      margin-bottom: 15px;
      background: linear-gradient(135deg, #3b82f6 0%, #ef4444 100%);
      border-radius: 6px;
    }
    
    /* Meeting card (bottom-right) */
    .meeting-card {
      display: flex;
      flex-direction: column;
    }
    
    .meeting-header {
      background: linear-gradient(135deg, #f97316 0%, #ec4899 100%);
      height: 6px;
      width: 30%;
      border-radius: 3px;
      margin-bottom: 15px;
    }
    
    .card-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 6px;
      letter-spacing: -0.01em;
      color: #f8fafc;
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      line-height: 1.3;
      max-width: 100%;
      transition: color 0.3s ease, transform 0.3s ease;
    }
    
    .card-subtitle {
      font-size: 11px;
      color: #94a3b8;
      margin-bottom: 12px;
      line-height: 1.4;
      overflow: visible;
      display: block;
      max-width: 100%;
    }
    
    .tag {
      display: inline-flex;
      align-items: center;
      background: rgba(201, 166, 103, 0.1);
      color: #ecd394;
      font-size: 10px;
      padding: 3px 6px;
      border-radius: 4px;
      margin-right: 5px;
    }
    
    .btn {
      display: block;
      width: 100%;
      padding: 6px 0;
      background: rgba(201, 166, 103, 0.1);
      color: #ecd394;
      text-align: center;
      border-radius: 6px;
      border: 1px solid rgba(201, 166, 103, 0.2);
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 12px;
      margin-top: auto;
    }
    
    .btn:hover {
      background: rgba(201, 166, 103, 0.2);
      border-color: rgba(201, 166, 103, 0.3);
    }
    
    .grid-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      overflow: visible;
      padding-top: 80px; /* Increased padding to push grid container down further */
    }
    
    /* Tagline area on the bottom left */
    .tagline-container {
      position: absolute;
      bottom: 40px;
      left: 40px;
      z-index: 106;
      max-width: 340px;
      transition: opacity 0.8s ease;
    }
    
    .tagline-text {
      font-size: 14px;
      line-height: 1.4;
      color: #ffffff;
      margin-bottom: 20px;
    }
    
    .waitlist-button {
      display: inline-block;
      background-color: white;
      color: #000;
      font-size: 14px;
      font-weight: 500;
      padding: 10px 20px;
      border-radius: 30px;
      text-decoration: none;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }
    
    /* Brand name on the bottom right */
    .brand-container {
      position: absolute;
      bottom: 40px;
      right: 40px;
      z-index: 106;
      text-align: right;
      transition: opacity 0.8s ease;
    }
    
    .brand-name {
      font-size: 64px;
      font-weight: 700;
      color: #ffffff;
      line-height: 0.9;
      letter-spacing: -0.02em;
    }
    
    .brand-tagline {
      font-size: 18px;
      color: #ffffff;
      margin-top: 10px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <!-- New entrance overlay structure with panoramic landscape -->
  <div class="entrance-overlay">
    <div class="entrance-image"></div>
    <div class="mask-container">
      <div class="mask-panel mask-left" id="maskLeft">
        <!-- Now use a real image element instead of a pseudo-element background -->
        <div class="panel-background left-background"></div>
      </div>
      <div class="mask-panel mask-center" id="maskCenter">
        <!-- Now use a real image element instead of a pseudo-element background -->
        <div class="panel-background center-background"></div>
        <div class="peephole" id="peephole">
          <!-- Main content directly inside the peephole -->
          <div class="peephole-content" id="peepholeContent">
            <div class="heading" id="heading">
              <h1>financial freedom</h1>
              <h2>at your fingertips</h2>
            </div>
            
            <div id="sphereContainer"></div>
            
            <div class="grid-container">
              <div class="grid" id="grid">
                <!-- Grid cells will be generated by JavaScript -->
              </div>
            </div>
            
            <!-- Decorative spheres inside the peephole -->
            <div class="sphere-decoration sphere-1"></div>
            <div class="sphere-decoration sphere-2"></div>
            <div class="sphere-decoration sphere-3"></div>
            <div class="sphere-decoration sphere-4"></div>
          </div>
        </div>
      </div>
      <div class="mask-panel mask-right" id="maskRight">
        <!-- Now use a real image element instead of a pseudo-element background -->
        <div class="panel-background right-background"></div>
      </div>
    </div>
    
    <!-- Add decorative spheres for the entrance overlay -->
    <div class="landscape-sphere sphere-top"></div>
    <div class="landscape-sphere sphere-left"></div>
    <div class="landscape-sphere sphere-right"></div>
    
    <!-- Add tagline on bottom left -->
    <div class="tagline-container">
      <p class="tagline-text">Your complete personal finance solution with budgeting tools, investment tracking, financial goal setting, transaction management, and automated bill payments in one elegant platform.</p>
      <a href="#" class="waitlist-button">Join the Waitlist</a>
    </div>
    
    <!-- Add brand name on bottom right -->
    <div class="brand-container">
      <h1 class="brand-name">Unbroken Pockets.</h1>
      <p class="brand-tagline">Master your money budget system</p>
    </div>
  </div>

  <!-- This empty container provides the scrollable height for the page -->
  <div class="container">
    <div style="height: 700vh;"></div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const grid = document.getElementById('grid');
      const heading = document.getElementById('heading');
      const sphereContainer = document.getElementById('sphereContainer');
      const container = document.querySelector('.container');
      const maskLeft = document.getElementById('maskLeft');
      const maskCenter = document.getElementById('maskCenter');
      const maskRight = document.getElementById('maskRight');
      const peephole = document.getElementById('peephole');
      const peepholeContent = document.getElementById('peepholeContent');
      const centerBackground = maskCenter.querySelector('.center-background');
      
      // Remove references to non-existent elements
      // const contentOverlay = document.getElementById('contentOverlay');
      // const fixedContent = document.getElementById('fixedContent');
      
      // Removed black rectangle references since we're using pseudo-elements
      
      // Generate grid cells dynamically
      const gridCellCount = 25; // 5x5 grid
      for (let i = 0; i < gridCellCount; i++) {
        const cell = document.createElement('div');
        cell.classList.add('grid-cell');
        cell.setAttribute('data-index', i);
        grid.appendChild(cell);
      }
      
      // Create feature cards
      const budgetCard = document.createElement('div');
      budgetCard.classList.add('card', 'in-grid');
      budgetCard.innerHTML = `
        <div class="card-title">Budget Planner</div>
        <div class="card-subtitle">Create and manage custom budgets with category tracking and spending analysis</div>
        <div class="tags">
          <span class="tag">Financial Planning</span>
        </div>
      `;
      
      const investmentCard = document.createElement('div');
      investmentCard.classList.add('card', 'in-grid');
      investmentCard.innerHTML = `
        <div class="card-title">Investment Portfolio</div>
        <div class="card-subtitle">Monitor your investments and track performance with detailed analytics</div>
        <div class="tags">
          <span class="tag">Wealth Building</span>
        </div>
      `;
      
      const goalCard = document.createElement('div');
      goalCard.classList.add('card', 'in-grid');
      goalCard.innerHTML = `
        <div class="card-title">Financial Goals</div>
        <div class="card-subtitle">Set personalized savings targets with detailed progress tracking</div>
        <div class="tags">
          <span class="tag">Goal Tracking</span>
        </div>
      `;
      
      const transactionCard = document.createElement('div');
      transactionCard.classList.add('card', 'in-grid');
      transactionCard.innerHTML = `
        <div class="card-title">Transaction History</div>
        <div class="card-subtitle">View and categorize all your financial transactions in one place</div>
        <div class="tags">
          <span class="tag">Expense Tracking</span>
        </div>
      `;
      
      const recurringCard = document.createElement('div');
      recurringCard.classList.add('card', 'in-grid');
      recurringCard.innerHTML = `
        <div class="card-title">Recurring Payments</div>
        <div class="card-subtitle">Manage subscriptions and automate bill tracking with reminders</div>
        <div class="tags">
          <span class="tag">Bill Management</span>
        </div>
      `;
      
      // New card: Debt Tracker
      const debtCard = document.createElement('div');
      debtCard.classList.add('card', 'in-grid');
      debtCard.innerHTML = `
        <div class="card-title">Debt Tracker</div>
        <div class="card-subtitle">Track and optimize debt payoff strategies to become debt-free faster</div>
        <div class="tags">
          <span class="tag">Debt Management</span>
        </div>
      `;
      
      // New card: Net Worth Calculator
      const netWorthCard = document.createElement('div');
      netWorthCard.classList.add('card', 'in-grid');
      netWorthCard.innerHTML = `
        <div class="card-title">Net Worth Calculator</div>
        <div class="card-subtitle">Calculate and visualize your total net worth across all assets and liabilities</div>
        <div class="tags">
          <span class="tag">Wealth Tracking</span>
        </div>
      `;
      
      // Place cards in fixed positions as specified
      // Note: Grid is zero-indexed, so we adjust the row/column values
      const cardPlacements = [
        { card: budgetCard, position: 0 },       // Column 1, Row 1 (position = (row-1)*5 + (column-1))
        { card: investmentCard, position: 3 },   // Column 4, Row 1
        { card: goalCard, position: 9 },         // Column 5, Row 2
        { card: transactionCard, position: 11 }, // Column 2, Row 3
        { card: recurringCard, position: 19 },   // Column 5, Row 4
        { card: debtCard, position: 22 },        // Column 3, Row 5
        { card: netWorthCard, position: 6 }      // Column 2, Row 2 (Row 6 exceeds the 5x5 grid, using Row 2 instead)
      ];
      
      // Place each card in its designated position
      cardPlacements.forEach(placement => {
        const cell = grid.querySelector(`[data-index="${placement.position}"]`);
        cell.appendChild(placement.card);
      });
      
      // Initialize Three.js for the golden sphere
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
      
      const renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true 
      });
      renderer.setSize(450, 450);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      sphereContainer.appendChild(renderer.domElement);
      
      // Create a sphere with gold material
      const geometry = new THREE.SphereGeometry(1, 64, 64);
      
      // Create gold material with enhanced reflection and depth
      const material = new THREE.MeshPhysicalMaterial({
        color: 0xc9a667,
        metalness: 0.9,
        roughness: 0.15,
        reflectivity: 0.9,
        clearcoat: 0.3, 
        clearcoatRoughness: 0.2,
        emissive: 0x7d694c,
        emissiveIntensity: 0.2
      });
      
      const sphere = new THREE.Mesh(geometry, material);
      sphere.castShadow = true;
      sphere.receiveShadow = true;
      scene.add(sphere);
      
      // Add a subtle shadow blob beneath the sphere (fake shadow)
      const shadowGeo = new THREE.CircleGeometry(1.2, 32);
      const shadowMat = new THREE.MeshBasicMaterial({ 
        color: 0x000000, 
        transparent: true, 
        opacity: 0.2,
        depthWrite: false
      });
      const shadowMesh = new THREE.Mesh(shadowGeo, shadowMat);
      shadowMesh.rotation.x = -Math.PI / 2;
      shadowMesh.position.y = -1.05;
      scene.add(shadowMesh);
      
      // Add directional light (top-left highlight)
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
      directionalLight.position.set(-1, 2, 1.5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
      
      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);
      
      // Add a soft point light from below for dramatic effect
      const pointLight = new THREE.PointLight(0xf1c232, 0.7);
      pointLight.position.set(0, -1.5, 0.5);
      scene.add(pointLight);
      
      // Add rim light from behind
      const rimLight = new THREE.DirectionalLight(0xffffff, 0.5);
      rimLight.position.set(0, 0, -2);
      scene.add(rimLight);
      
      // Position camera
      camera.position.z = 2.5;
      
      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        sphere.rotation.y += 0.005;
        renderer.render(scene, camera);
      }
      animate();
      
      // Initialize states
      maskLeft.style.transform = 'translateY(0)';
      maskRight.style.transform = 'translateY(0)';
      maskCenter.style.opacity = '1';
      maskCenter.style.transform = 'scale(1)';
      if (centerBackground) {
        centerBackground.style.transform = 'scale(1)';
      }
      
      // Set initial peephole size back to 0 for proper animation
      peephole.style.width = '0';
      peephole.style.height = '0';
      peepholeContent.style.opacity = '0';
      peepholeContent.style.transform = 'scale(0.9)';
      
      // Reset grid and heading
      grid.style.transform = 'perspective(1000px) rotateX(35deg) scale(0.7)';
      heading.style.transform = 'scale(0.8)';
      
      // Set initial z-indexes
      maskLeft.style.zIndex = '10';
      maskRight.style.zIndex = '10';
      maskCenter.style.zIndex = '11';
      peephole.style.zIndex = '20'; // Same as in CSS
      document.querySelector('.entrance-overlay').style.zIndex = '100';
      
      // Make sure entrance overlay starts fully visible
      document.querySelector('.entrance-overlay').style.opacity = '1';

      // Add some animation to the landscape spheres
      const landscapeSpheres = document.querySelectorAll('.landscape-sphere');
      landscapeSpheres.forEach((sphere, index) => {
        // Random initial position offset
        const xOffset = (Math.random() - 0.5) * 40;
        const yOffset = (Math.random() - 0.5) * 40;
        const zOffset = (Math.random() - 0.5) * 30;
        const rotation = Math.random() * 360;
        
        // Store base positions in dataset for mouse movement calculations
        sphere.dataset.baseX = xOffset;
        sphere.dataset.baseY = yOffset;
        sphere.dataset.baseZ = zOffset;
        sphere.dataset.baseRotation = rotation;
        
        // Apply initial 3D transforms
        sphere.style.transform = `translate3d(${xOffset}px, ${yOffset}px, ${zOffset}px) rotateY(${rotation}deg)`;
        
        // Create complex floating animation
        const animateSphere = () => {
          // Generate new random positions for smooth movement
          const newXOffset = (Math.random() - 0.5) * 40;
          const newYOffset = (Math.random() - 0.5) * 40;
          const newZOffset = (Math.random() - 0.5) * 30;
          const newRotation = Math.random() * 360;
          
          // Update base positions in dataset
          sphere.dataset.baseX = newXOffset;
          sphere.dataset.baseY = newYOffset;
          sphere.dataset.baseZ = newZOffset;
          sphere.dataset.baseRotation = newRotation;
          
          // Apply smooth transition if not scrolling
          if (!isScrolling) {
          sphere.style.transition = 'transform 8s cubic-bezier(0.19, 1, 0.22, 1)';
            sphere.style.transform = `translate3d(${newXOffset}px, ${newYOffset}px, ${newZOffset}px) rotateY(${newRotation}deg)`;
          }
          
          // Schedule next animation
          setTimeout(animateSphere, 8000 + Math.random() * 4000);
        };
        
        // Start the animation loop
        setTimeout(animateSphere, 1000 + Math.random() * 2000);
      });
      
      // Mouse movement parallax effect
      let isScrolling = false;
      let scrollTimeout;
      const parallaxContainer = document.querySelector('.mask-container');
      const parallaxSpheres = document.querySelectorAll('.landscape-sphere');
      const contentSpheres = document.querySelectorAll('.sphere-decoration');
      const parallaxStrength = 20; // Adjust this to control the effect intensity
      let mouseX = 0;
      let mouseY = 0;
      
      // Start continuous animation for content spheres
      function animateContentSpheres() {
        // Continuously animate content spheres
        contentSpheres.forEach((sphere, index) => {
          const depth = 0.5 + (index * 0.3);
          
          // Calculate a unique floating movement for each sphere
          const time = Date.now() * 0.001; // Convert to seconds
          const floatX = Math.sin(time + index * 0.5) * 15; 
          const floatY = Math.cos(time + index * 0.3) * 15;
          const floatZ = Math.sin(time * 0.5 + index * 0.2) * 10;
          const rotateY = Math.sin(time * 0.3) * 30;
          
          // Combine floating movement with mouse parallax
          const moveX = floatX - mouseX * parallaxStrength * depth;
          const moveY = floatY - mouseY * parallaxStrength * depth;
          
          // Apply the combined transformation
          sphere.style.transform = `translate3d(${moveX}px, ${moveY}px, ${floatZ}px) rotateY(${rotateY}deg)`;
        });
        
        // Continue animation loop
        requestAnimationFrame(animateContentSpheres);
      }
      
      // Start the animation loop
      animateContentSpheres();
      
      // Detect when user is scrolling
      window.addEventListener('scroll', () => {
        isScrolling = true;
        
        // Reset the scrolling flag after scrolling stops
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          isScrolling = false;
          
          // Reset spheres to their base positions after scrolling stops
          parallaxSpheres.forEach(sphere => {
            if (sphere.dataset.baseX) {
              sphere.style.transition = 'transform 0.5s ease-out';
              sphere.style.transform = `translate3d(${sphere.dataset.baseX}px, ${sphere.dataset.baseY}px, ${sphere.dataset.baseZ}px) rotateY(${sphere.dataset.baseRotation}deg)`;
            }
          });
        }, 100);
      });
      
      // Track mouse movement and apply parallax effect
      document.addEventListener('mousemove', (e) => {
        if (isScrolling) return; // Skip if user is scrolling
        
        mouseX = e.clientX / window.innerWidth - 0.5;
        mouseY = e.clientY / window.innerHeight - 0.5;
        
        // Move background image container in opposite direction of mouse (subtle effect)
        requestAnimationFrame(() => {
          if (parallaxContainer) {
            parallaxContainer.style.transform = `translate3d(${-mouseX * parallaxStrength}px, ${-mouseY * parallaxStrength}px, 0)`;
          }
          
          // Move spheres with different depths for 3D effect
          parallaxSpheres.forEach((sphere, index) => {
            if (!sphere.dataset.baseX) return;
            
            const depth = 1 + (index * 0.5);
            const baseX = parseFloat(sphere.dataset.baseX);
            const baseY = parseFloat(sphere.dataset.baseY);
            const baseZ = parseFloat(sphere.dataset.baseZ);
            const baseRotation = parseFloat(sphere.dataset.baseRotation);
            
            // Apply mouse movement to base position
            sphere.style.transition = 'transform 0.1s ease-out';
            sphere.style.transform = `translate3d(${baseX - mouseX * parallaxStrength * depth}px, ${baseY - mouseY * parallaxStrength * depth}px, ${baseZ}px) rotateY(${baseRotation + mouseX * 20}deg)`;
          });
        });
      });
      
      // Handle scrolling animations
      window.addEventListener('scroll', () => {
        const scrollPosition = window.scrollY;
        const viewportHeight = window.innerHeight;
        const totalHeight = container.clientHeight;
        const scrollRatio = scrollPosition / (totalHeight - viewportHeight);
        
        // Animation timing constants
        const introAnimStart = 0.01;
        const panelExitEnd = 0.08; // Point where panels have completely exited
        const zoomStartPoint = 0.09; // Start zoom AFTER panels have exited
        const mainAnimStart = 0.15;
        const mainAnimEnd = 0.4;
        const cardsTransitionStart = mainAnimEnd + 0.05; // Start cards transition AFTER grid completes
        const cardsTransitionEnd = cardsTransitionStart + 0.1; // Cards transition duration
        
        // Handle scrolling back up - reset animations when needed
        if (scrollRatio < introAnimStart && peephole.style.width !== '0px') {
          // Reset to initial state
          maskLeft.style.transform = 'translateY(0)';
          maskRight.style.transform = 'translateY(0)';
          maskCenter.style.opacity = '1';
          maskCenter.style.transform = 'scale(1)'; // Reset center panel zoom
          if (centerBackground) {
            centerBackground.style.transform = 'scale(1)'; // Reset background zoom
            centerBackground.style.opacity = '0.7'; // Reset to initial opacity
          }
          peephole.style.width = '0';
          peephole.style.height = '0';
          peephole.style.transform = 'translate(-50%, -50%)'; // Reset transform
          peephole.classList.remove('expanded');
          peepholeContent.style.opacity = '0';
          peepholeContent.style.transform = 'scale(0.9)';
          
          // Make sure entrance overlay is fully visible
          document.querySelector('.entrance-overlay').style.opacity = '1';
        }

        // Reset cards to original positions if scrolling up past the card transition point
        if (scrollRatio < cardsTransitionStart && document.querySelector('.card.horizontal-line')) {
          cardPlacements.forEach(placement => {
            const card = placement.card;
            if (!card) return;
            
            card.classList.remove('horizontal-line');
            card.style.position = '';
            card.style.top = '';
            card.style.left = '';
            card.style.opacity = '1';
            card.style.transform = 'translate(-50%, -50%)';
          });
        }
        
        // Phase 1: Initial animation - move left and right panels up out of frame
        if (scrollRatio > introAnimStart && scrollRatio <= panelExitEnd) {
          // Calculate progress for panel exit (0 to 1)
          const panelExitProgress = Math.min(1, (scrollRatio - introAnimStart) / (panelExitEnd - introAnimStart));
          
          // Move left and right masks up out of frame - faster animation
          maskLeft.style.transition = 'transform 0.8s cubic-bezier(0.19, 1, 0.22, 1)';
          maskRight.style.transition = 'transform 0.8s cubic-bezier(0.19, 1, 0.22, 1)';
          
          // Use a much larger value to ensure panels completely move offscreen
          const moveUpAmount = Math.min(200, panelExitProgress * 200);
          
          // Apply transform to the entire panel which will include the background
          maskLeft.style.transform = `translateY(-${moveUpAmount}vh)`;
          maskRight.style.transform = `translateY(-${moveUpAmount}vh)`;
          
          // Create a growing peephole with content
          const peepholeProgress = panelExitProgress * 0.7;
          const peepholeWidth = Math.min(60, peepholeProgress * 60); 
          const peepholeHeight = Math.min(75, peepholeProgress * 75);
          
          // Set the peephole dimensions explicitly
          peephole.style.width = `${peepholeWidth}%`;
          peephole.style.height = `${peepholeHeight}%`;
          peephole.style.borderRadius = `${40}% / ${60}%`; // Pill shape
          
          // Ensure the peephole content becomes visible as it grows
          if (peepholeProgress > 0.2) {
            // Start showing content when peephole is somewhat visible
            const contentVisibility = (peepholeProgress - 0.2) / 0.8; // 0 to 1 scale
            peepholeContent.style.opacity = Math.min(1, contentVisibility * 2);
            
            // Scale content from 0.9 to 1 as peephole grows
            const contentScale = 0.9 + (contentVisibility * 0.1);
            peepholeContent.style.transform = `scale(${contentScale})`;
            
            // Also scale the heading and grid as peephole grows
            heading.style.transform = `scale(${0.8 + contentVisibility * 0.2})`;
            grid.style.transform = `perspective(1000px) rotateX(${35 - contentVisibility * 5}deg) scale(${0.7 + contentVisibility * 0.3})`;
          } else {
            peepholeContent.style.opacity = 0;
          }
          
          // Reset center panel - explicitly ensure it's not zooming during this phase
          maskCenter.style.transform = 'scale(1)';
          if (centerBackground) {
            centerBackground.style.transform = 'scale(1)';
          }
          
          // Ensure the center mask shows the peephole correctly
          maskCenter.style.zIndex = '11'; 
          
          // Get references to the tagline and brand containers
          const taglineContainer = document.querySelector('.tagline-container');
          const brandContainer = document.querySelector('.brand-container');
          
          // During the panels moving up, maintain full opacity of the tagline and brand text
          if (taglineContainer && brandContainer) {
            // Keep text fully visible throughout the animation
            taglineContainer.style.opacity = 1;
            brandContainer.style.opacity = 1;
          }
        }
        
        // Phase 2: Center panel zoom animation - starts AFTER side panels have exited
        if (scrollRatio > zoomStartPoint) {
          // Calculate zoom progress (0 to 1)
          const zoomProgress = Math.min(1, (scrollRatio - zoomStartPoint) / 0.05);
          
          // Apply scaling transform to peephole
          peephole.style.transform = `translate(-50%, -50%) scale(${1 + zoomProgress * 1.5})`;
          
          // Add transform to center panel to create zoom effect
          const panelZoomFactor = zoomProgress * 1.5; 
          maskCenter.style.transform = `scale(${1 + panelZoomFactor})`;
          
          // Scale the center background image for an immersive zoom effect
          if (centerBackground) {
            const bgZoomFactor = 1 + (zoomProgress * 1.2);
            centerBackground.style.transform = `scale(${bgZoomFactor})`;
            centerBackground.style.opacity = Math.max(0.7, Math.min(1, 0.7 + zoomProgress * 0.3));
          }
          
          // Make the center panel fade out as zoom progresses
          maskCenter.style.opacity = Math.max(0, 1 - zoomProgress * 1.2);
          
          // Fade out the entire entrance overlay
          const entranceOverlay = document.querySelector('.entrance-overlay');
          if (entranceOverlay && zoomProgress > 0.6) {
            entranceOverlay.style.opacity = Math.max(0, 1 - (zoomProgress - 0.6) * 2.5);
          }
        }
        
        // Handle the rest of the animations (grid, sphere, etc.) as scroll continues
        if (scrollRatio > mainAnimStart) {
          // Calculate animation progress - how far we are in the transition
          const animationProgress = Math.min(1, (scrollRatio - mainAnimStart) / 
                                           (mainAnimEnd - mainAnimStart));
          
          // Inside peephole content animation
          if (animationProgress > 0) {
            // Rotation transition - grid becomes more upright
            const rotateValue = Math.max(0, 35 - (animationProgress * 35));
            
            // Apply smooth scale and rotation to grid
            grid.style.transition = 'transform 1.5s cubic-bezier(0.19, 1, 0.22, 1)';
            grid.style.transform = `perspective(1000px) rotateX(${rotateValue}deg) scale(${0.7 + animationProgress * 0.3})`;
            
            // Sphere animation - float up and fade out as we scroll
            const sphereYOffset = -50 * animationProgress;
            const sphereOpacity = Math.max(0, 1 - animationProgress * 1.2);
            sphereContainer.style.transform = `translate(-50%, ${sphereYOffset}px) scale(${1 - animationProgress * 0.2})`;
            sphereContainer.style.opacity = sphereOpacity;
            
            // Heading animation - move up and fade
            const headingYOffset = -100 * animationProgress;
            heading.style.transform = `translateY(${headingYOffset}px) scale(${1 - animationProgress * 0.1})`;
            heading.style.opacity = Math.max(0, 1 - animationProgress * 1.2);
            
            // When animation is complete, peephole should be fully expanded
            if (animationProgress >= 0.9) {
              // Ensure the peephole is fully expanded
              peephole.style.width = '100%';
              peephole.style.height = '100%';
              peephole.style.borderRadius = '0';
              peephole.classList.add('expanded');
              
              // Entrance overlay should be completely gone or very faded
              document.querySelector('.entrance-overlay').style.opacity = '0.2';
              
              // Feature cards animation when at full view
              if (scrollRatio >= cardsTransitionStart) {
                // Calculate progress of the card transition animation
                const cardsProgress = Math.min(1, (scrollRatio - cardsTransitionStart) / 
                                            (cardsTransitionEnd - cardsTransitionStart));
                
                // Apply card transitions inside the peephole content
                if (cardsProgress > 0) {
                  // Arrange cards in a horizontal line
                  cardPlacements.forEach((placement, index) => {
                    const card = placement.card;
                    if (!card) return;
                    
                    // Add horizontal-line class to handle styling
                    if (!card.classList.contains('horizontal-line')) {
                      card.classList.add('horizontal-line');
                    }
                    
                    // Calculate horizontal position
                    const totalWidth = cardPlacements.length * 140; // Card width + margin
                    const startX = 50 - (totalWidth / 2); // Center the line
                    const xPos = startX + (index * 140);
                    
                    // Set card position
                    card.style.transition = 'all 0.8s cubic-bezier(0.19, 1, 0.22, 1)';
                    card.style.position = 'absolute';
                    card.style.left = `${xPos}px`;
                    card.style.top = '50%';
                    
                    // Scale card based on progress
                    const scale = 1 + (cardsProgress * 0.1);
                    card.style.transform = `translate(-50%, -50%) scale(${scale})`;
                    card.style.opacity = Math.min(1, cardsProgress * 2);
                  });
                }
              }
            }
          }
        }
      });
      
      // Handle resize events properly
      let resizeTimer;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          // Force recalculation if in the transition zone
          const scrollPosition = window.scrollY;
          const viewportHeight = window.innerHeight;
          const totalHeight = container.clientHeight;
          const scrollRatio = scrollPosition / (totalHeight - viewportHeight);
          
          if (scrollRatio >= cardsTransitionStart && document.body.hasAttribute('data-cards-setup')) {
            // Reset the setup flag to force recalculation of positions
            document.body.removeAttribute('data-cards-setup');
            
            // Trigger a small scroll to force update
            window.scrollBy(0, 1);
            setTimeout(() => window.scrollBy(0, -1), 10);
          }
        }, 150);
      });
      
      // Add styles for card transition
      const transitionStyles = document.createElement('style');
      transitionStyles.textContent = `
        .card.in-line {
          transition: all 0.6s cubic-bezier(0.19, 1, 0.22, 1) !important;
          pointer-events: auto !important;
        }
        #horizontal-line-container {
          pointer-events: none;
        }
        #horizontal-line-container .card {
          pointer-events: auto;
        }
      `;
      document.head.appendChild(transitionStyles);
      
      // Trigger initial scroll events - more aggressive approach to ensure animation starts
      setTimeout(() => {
        // Create a small scroll to trigger the animation
        window.scrollTo(0, 10);
        setTimeout(() => {
          window.scrollTo(0, 0);
        }, 200);
      }, 600);
    });
  </script>
</body>
</html> 